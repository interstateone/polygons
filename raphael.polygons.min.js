// ************************************************************************************************
// 
// RaphaÃ«l.js Polygon Intersection
// by Brandon Evans, 2012
// brandonevans.ca
// @interstateone
// 
// Based on Efficient Clipping of Arbitrary Polygons by Gunther Greiner and Kai Hormann
// http://davis.wpi.edu/~matt/courses/clipping/
// 
// Gives the ability to find the intersection of two or more polygons as a new polygon.
// They can be concave or convex, but self-intersecting may not work properly.
// Uses "node" objects to represent vertices of polygons and their intersection points.
// 
// Utility Functions:
// 	- doesIntersect
// 		Takes two pairs of node objects representing line segments: no ------- n1, n2 ------- n3
// 		If they intersect a node is returned, if they don't intersect then "false" is returned
// 
// 	- norm
// 		Takes one pair of node objects representing one line segment
// 		Returns the norm/length/magnitude of the line
// 
// 	- clipIntersect
// 		Needs to be deprecated, not really needed
// 
// 	- containmentTest
// 		Uses the even/odd rule to determine whether a point is inside another polygon
// 		Used by markEntryPoints in order to determine whether an intersection point is an entry or exit
// 		Takes a single node and a node array representing a polygon
// 		Returns 0 for an outside point or 1 for an inside point
// 
// 	- markEntryPoints
// 		Marks the intersection points in one polygon as being entry or exits for the edges of the other polygon
// 		Uses containmentTest to determine the initial status, then alternates entry/exit
// 		Takes two node arrays to compare, and a flag setting
// 		Returns the updated node array with entry/exit statuses
// 
// 	- Raphael.el.toNodes
// 		Function that converts an element's path to the node array that's needed for clipping
// 		Also makes sure that the nodes are in CW order
// 		Returns a node array in CW order
// 
// The Good Stuff:
// 	- Raphael.fn.clip
// 		The general clipping function
// 		Takes two node arrays representing subject and clip, but the order is not important
// 		Returns the node array of the intersection or false if there isn't an intersection
// 
// 	- Raphael.st.clip
// 		Takes advantage of the general clip function with sets
// 		Useful if there are more than two polygons you need to clip, this will find the total intersection
// 
// ************************************************************************************************
// Node object
// Used for each vertex of a polygon and the intersects
function node(a,b,c,d){this.x=a;this.y=b;this.intersect=c;this.alpha=d;this.entry=!1;this.visited=!1;this.onLine=function(a,b){var c=new node(b.x-a.x,b.y-a.y),d=new node(this.x-a.x,this.y-a.y),e,f=c.x*c.x+c.y*c.y;if(f==0)return this.x==a.x&&this.y==a.y;e=(c.x*d.x+c.y*d.y)/f;return e>=0&&e<=1};this.toString=function(){return this.x+","+this.y}}doesIntersect=function(a,b,c,d){var e=(d.y-c.y)*(b.x-a.x)-(d.x-c.x)*(b.y-a.y);if(e===0)return!1;var f=((d.x-c.x)*(a.y-c.y)-(d.y-c.y)*(a.x-c.x))/e,g=((b.x-a.x)*(a.y-c.y)-(b.y-a.y)*(a.x-c.x))/e,h=a.x+f*(b.x-a.x),i=a.y+f*(b.y-a.y),j=new node(h,i,!0,0);return 0<=f&&f<=1&&0<=g&&g<=1?j:!1};norm=function(a,b){return Math.sqrt((b.x-a.x)*(b.x-a.x)+(b.y-a.y)*(b.y-a.y))};clipIntersect=function(a,b,c,d){var e,f,g;g=doesIntersect(a,b,c,d);if(!g)return!1;var e=norm(a,g)/norm(a,b),f=norm(c,g)/norm(c,d);return{alphaS:e,alphaC:f,x:g.x,y:g.y}};containmentTest=function(a,b){var c,d=new node(0,a.y,!1,0),e=0;for(c=0;c<b.length;c++)clipIntersect(d,a,b[c],b[c===b.length-1?0:c+1])&&e++;delete d;return e%2};markEntryPoints=function(a,b,c){var d=containmentTest(a[0],b),e;c&&(d=1-d);for(e=0;e<b.length;e++)if(b[e].intersect){b[e].entry=d;d=1-d}return b};Raphael.fn.clip=function(a,b){var c=a.length,d=b.length,e,f,g,h,i;for(e=0;e<c;e++)if(!a[e].intersect)for(f=0;f<d;f++)if(!b[f].intersect){e+1===c?h=-e:h=1;while(a[e+h].intersect){h++;e+h===c&&(h=-e)}f+1===d?i=-f:i=1;while(b[f+i].intersect){i++;f+i===d&&(i=-f)}var j=clipIntersect(a[e],a[e+h],b[f],b[f+i]);if(j){a.splice(e+1,0,new node(j.x,j.y,!0,0));b.splice(f+1,0,new node(j.x,j.y,!0,0));c++;d++}}b=markEntryPoints(a,b,!0);a=markEntryPoints(b,a,!0);var h=0,k=a[h],l=[],m=!0,n=!0;while(!(k.intersect&&k.entry>0)){h++;k=a[h]}a[h].visited=!0;k=a[h];l.push(k);h++;if(!m&&h===d||m&&h===c)h=0;k=a[h];a[h].visited=!0;while(k.x!==l[0].x&&k.y!==l[0].y){l.push(k);if(k.entry!==!1){if(m){h=0;while(b[h].x!=k.x&&b[h].y!=k.y)h++;b[h].entry>0?n=!0:b[h].entry===0&&(n=!1)}else{h=0;while(a[h].x!=k.x&&a[h].y!=k.y)h++;a[h].entry>0?n=!0:a[h].entry===0&&(n=!1)}n?h++:h--;m=!m;m&&h===c?h=0:m&&h<0?h=c-1:!m&&h===d?h=0:!m&&h<0&&(h=d-1);if(m){a[h].visited=!0;k=a[h]}else{b[h].visited=!0;k=b[h]}}else{n?h++:h--;m&&h===c?h=0:m&&h<0?h=c-1:!m&&h===d?h=0:!m&&h<0&&(h=d-1);if(m){a[h].visited=!0;k=a[h]}else{b[h].visited=!0;k=b[h]}}}return l};Raphael.st.clip=function(){var a=this.length,b=0,c=1,d,e,f=null;d=this[b].toNodes();e=this[c].toNodes();f=paper.clip(d,e);if(a>=3)for(c=2;c<a;c++){e=this[c].toNodes();f=paper.path("M"+f.join("L")+"Z").toNodes();f=paper.clip(f,e)}if(f)var g=paper.path("M"+f.join("L")+"Z");return g?g:!1};Raphael.el.toNodes=function(){var a=Raphael.parsePathString(this.attr("path")),b=[];a.pop();a.forEach(function(a){b.push(new node(a[1],a[2],!1,0))});var c=0;for(var d=0;d<b.length;d++)c+=(b[d+1<b.length?d+1:0].x-b[d].x)*(b[d+1<b.length?d+1:0].y+b[d].y);c<0&&b.reverse();return b};